Okay, let's continue with the **Chalchitra Cookbook: The Definitive Guide to Motion Canvas**.

---

## Part 10: Leveraging Core Utilities üõ†Ô∏è

Beyond the main components and animation functions, Motion Canvas (`@motion-canvas/core`) provides a rich set of utilities‚Äîhelper classes and functions‚Äîthat can simplify common tasks, manage complex data types more effectively, generate procedural content, and aid in debugging.

---

### 10.1 Random Number Generation (`Random`)

**Goal:** Learn to generate various types of random values for procedural animations, particle effects, or adding organic variations.

**Core Concepts Involved:** `Random` class, seedable pseudo-random number generation.

**The `Random` Class:**

Motion Canvas includes a `Random` class for generating pseudo-random numbers. A key feature is that its instances can be seeded, ensuring reproducible "random" sequences, which is invaluable for consistent animation rendering and debugging.

**Creating and Using a `Random` Instance:**

```typescript
import { makeScene2D, Circle, Rect } from "@motion-canvas/2d";
import {
  createRef,
  Random,
  Vector2,
  Color,
  loop,
  waitFor,
  chain,
} from "@motion-canvas/core";

export default makeScene2D(function* (view) {
  // Create a seeded Random instance for reproducible results
  const random = new Random(12345); // Use any seed number

  // If you need different random sequences, create another instance with a different seed
  // const anotherRandom = new Random('some-other-seed-string');

  // Create some shapes
  const circles: Circle[] = [];
  for (let i = 0; i < 5; i++) {
    const circle = createRef<Circle>();
    view.add(
      <Circle
        ref={circle}
        size={random.nextInt(30, 80)} // Random integer size between 30 and 80
        fill={random.nextColor()} // Random fully opaque color
        // Position using random vectors (more on nextVector2 below)
        x={random.nextFloat(-view.width() / 2 + 50, view.width() / 2 - 50)}
        y={random.nextFloat(-view.height() / 2 + 50, view.height() / 2 - 50)}
        opacity={0}
      />
    );
    circles.push(circle()); // Store the node instance
  }

  // Animate them
  for (const circle of circles) {
    yield* circle.opacity(random.nextFloat(0.5, 1), 0.5); // Random opacity
    yield* loop(3, () =>
      // Loop 3 times for each circle
      chain(
        circle.position(
          random.nextVector2(view.size().scale(0.4)), // Random position within ~40% of view center
          random.nextFloat(0.8, 1.5) // Random duration
        ),
        waitFor(random.nextFloat(0.1, 0.3))
      )
    );
  }
});
```

**Key `Random` Methods:**

- **`constructor(seed?: string | number)`**: Creates a new `Random` generator. If no seed is provided, it might use a time-based seed (less reproducible).
- **`seed(value: string | number)`**: Re-seeds the generator.
- **Numbers:**
  - `nextFloat(min: number = 0, max: number = 1): number`: Returns a random floating-point number between `min` (inclusive) and `max` (exclusive).
  - `nextInt(min: number, max: number): number`: Returns a random integer between `min` (inclusive) and `max` (exclusive).
  - `nextGaussian(mean = 0, standardDeviation = 1)`: Returns a normally distributed random number.
- **Boolean:**
  - `nextBool(probability: number = 0.5): boolean`: Returns `true` with the given `probability` (0 to 1).
- **Vectors:**
  - `nextVector2(maxLength: number = 1): Vector2`: Returns a random `Vector2` with a magnitude between 0 and `maxLength`.
  - `nextVector2InRect(rect: Rect | BBox | SignalValue<PossibleRectangle>): Vector2`: Returns a random `Vector2` within the bounds of the given rectangle.
  - (Similar methods for `nextVector3`, `nextVector4` might exist if you're using 3D aspects, but `nextVector2` is most common for 2D).
- **Colors:**
  - `nextColor(): Color`: Returns a random `Color` (usually fully opaque, random hue, saturation, value).
  - `nextColorWithAlpha(minAlpha = 0, maxAlpha = 1)`: Returns a random color with random alpha.
  - `nextGray(min = 0, max = 1)`: Returns a random grayscale color.
- **Arrays & Selections:**
  - `pick<T>(array: readonly T[]): T | undefined`: Returns a random element from an array.
  - `shuffle<T>(array: T[]): T[]`: Shuffles an array in place (Fisher-Yates algorithm) and returns it.
  - `onCircle(radius = 1, phase = 0)`: Returns a random point on a circle's circumference.
  - `inCircle(radius = 1, phase = 0)`: Returns a random point within a circle.
  - `onSphere`, `inSphere`: For 3D.

**Importance of Seeding:**

Using a specific seed (e.g., `new Random(123)`) ensures that every time your animation runs with that seed, the sequence of "random" numbers generated by that instance will be identical. This is crucial for:

- **Reproducibility:** Getting the exact same animation output every time.
- **Debugging:** If a bug occurs with a particular random configuration, you can reproduce it using the same seed.

If you want different random results each time you run the animation in development, you could seed it with something variable, like `new Random(Date.now())`, but for final renders, a fixed seed is usually preferred. Motion Canvas's player might also manage a global random seed that can be controlled from the editor.

---

### 10.2 Advanced `Vector2` and `Color` Utilities (Revisit/Expand)

While Part 5 covered the basics of `Vector2` and `Color`, these classes have many more utility methods.

**Goal:** Highlight more advanced or specific methods for `Vector2` and `Color` manipulation.

**Advanced `Vector2` Methods:**

(Many of these return new `Vector2` instances, promoting immutability)

- **Creation & Conversion:**
  - `Vector2.fromScalar(value: number): Vector2`: Creates `new Vector2(value, value)`.
  - `Vector2.fromPolar(radius: number, angle: number | Angle): Vector2`: Creates a vector from polar coordinates (angle in radians).
  - `Vector2.fromDegrees(radius: number, degrees: number): Vector2`: Creates from polar coordinates (angle in degrees).
  - `vector.array(): [number, number]`: Returns `[x, y]`.
  - `vector.object(): {x: number, y: number}`: Returns `{x, y}`.
- **Comparison & Clamping:**
  - `Vector2.min(a: PossibleVector2, b: PossibleVector2): Vector2`: Component-wise minimum.
  - `Vector2.max(a: PossibleVector2, b: PossibleVector2): Vector2`: Component-wise maximum.
  - `vector.clamp(min: PossibleVector2, max: PossibleVector2): Vector2`: Clamps each component of `vector` between the corresponding components of `min` and `max`.
  - `vector.clampMagnitude(maxMagnitude: number)`: Clamps the vector's magnitude to `maxMagnitude`.
- **Rounding:**
  - `vector.floored: Vector2`: New vector with components floored.
  - `vector.ceiled: Vector2`: New vector with components ceiled.
  - `vector.rounded: Vector2`: New vector with components rounded.
- **Geometric:**
  - `vector.rotated(angle: number | Angle): Vector2`: Rotates by angle (radians).
  - `vector.rotatedDegrees(degrees: number): Vector2`: Rotates by angle (degrees).
  - `vector.angleBetween(other: PossibleVector2): number`: Angle (radians) to the other vector.
  - `vector.angleBetweenDegrees(other: PossibleVector2): number`: Angle (degrees).
  - `vector.directionTo(other: PossibleVector2): Vector2`: Normalized vector pointing from this vector to another.
  - `vector.normal: Vector2`: A perpendicular vector (rotated 90 degrees counter-clockwise).

**Advanced `Color` Methods:**

(Many methods return new `Color` instances)

- **Creation & Conversion:**
  - `Color.fromHSL(hue: number, saturation: number, lightness: number): Color`
  - `Color.fromHSV(hue: number, saturation: number, value: number): Color`
  - `Color.fromCMYK(cyan: number, magenta: number, yellow: number, key: number): Color`
  - `color.rgb(): {r: number, g: number, b: number}`
  - `color.hsl(): {h: number, s: number, l: number}`
  - `color.hsv(): {h: number, s: number, v: number}`
  - `color.alpha(value?: number)`: Gets or sets alpha (returns new `Color` if setting).
- **Color Manipulation:**
  - `color.lerp(to: PossibleColor, t: number): Color`: Linear interpolation to another color.
  - `color.saturate(amount: number): Color`: Increases saturation.
  - `color.desaturate(amount: number): Color`: Decreases saturation.
  - `color.lighten(amount: number): Color`: Increases lightness.
  - `color.darken(amount: number): Color`: Decreases lightness.
  - `color.invert(): Color`: Inverts the color.
  - `color.grayscale(): Color`: Converts to grayscale.
- **Color Properties & Checks:**
  - `color.luminance(): number`: Relative luminance (0-1).
  - `color.contrast(other: PossibleColor): number`: Contrast ratio.
  - `color.isDark(): boolean`
  - `color.isLight(): boolean`
  - `color.hue(): number` (0-360), `color.saturation(): number` (0-1), `color.lightness(): number` (0-1), `color.value(): number` (0-1 for HSV).

**Example Usage:**

```typescript
import { makeScene2D, Circle } from "@motion-canvas/2d";
import {
  createRef,
  Vector2,
  Color,
  loop,
  chain,
  waitFor,
} from "@motion-canvas/core";

export default makeScene2D(function* (view) {
  const movingCircle = createRef<Circle>();
  const startPos = new Vector2(-200, 0);
  const endPos = new Vector2(200, 0);
  const initialColor = new Color("blue");

  view.add(
    <Circle
      ref={movingCircle}
      position={startPos}
      size={80}
      fill={initialColor}
    />
  );

  // Use Vector2.lerp inside a tween
  yield* tween(2, (t) => {
    movingCircle().position(startPos.lerp(endPos, t)); // Lerp position
    movingCircle().fill(initialColor.lerp(Color.red, t)); // Lerp color
  });

  yield* waitFor(0.5);

  // Animate hue of the circle
  const currentColor = createSignal(new Color("red"));
  movingCircle().fill(() => currentColor());

  yield* loop(
    360,
    (
      i // Rotate hue by 360 degrees
    ) =>
      chain(
        waitFor(1 / 60), // Update roughly 60 times a second
        () => {
          // This is a "callback task"
          currentColor(currentColor().hue(currentColor().hue() + 1)); // Increment hue
        }
      )
  );
});
```

---

### 10.3 Timing and Frame Utilities

**Goal:** Use helper functions for converting between seconds and frames, and formatting time for display.

**Core Concepts Involved:** Frame rate (FPS), `secondsToFrames`, `framesToSeconds`, `TimeFormatter`.

**Utilities:**

1.  **`secondsToFrames(seconds: number, fps?: number): number`**

    - Converts a duration in seconds to a number of frames.
    - If `fps` is not provided, it might try to use the project's current FPS (e.g., `view.fps` or a globally configured FPS for rendering).

    ```typescript
    import { secondsToFrames, useProject } from "@motion-canvas/core";
    // ...
    // const project = useProject();
    // const durationInSeconds = 2.5;
    // const frameCount = secondsToFrames(durationInSeconds, project.framerate.fps);
    // console.log(`${durationInSeconds}s is ${frameCount} frames at ${project.framerate.fps} FPS`);
    ```

2.  **`framesToSeconds(frames: number, fps?: number): number`**

    - Converts a number of frames to a duration in seconds.

    ```typescript
    import { framesToSeconds, useProject } from "@motion-canvas/core";
    // ...
    // const project = useProject();
    // const numberOfFrames = 150;
    // const duration = framesToSeconds(numberOfFrames, project.framerate.fps);
    // console.log(`${numberOfFrames} frames is ${duration}s at ${project.framerate.fps} FPS`);
    ```

    - Accessing FPS:
      - `view.framerate`: Within a scene, `view.framerate` provides information about the current frame rate and time.
      - `useProject().framerate.fps`: Gets the configured FPS of the project (often relevant for rendering).

3.  **`TimeFormatter.format(seconds: number, showMilliseconds: boolean = true): string`**
    - Formats a time in seconds into a human-readable string like `MM:SS.mmm` or `MM:SS`.
    ```typescript
    import { TimeFormatter, waitFor } from "@motion-canvas/core";
    import { Txt } from "@motion-canvas/2d";
    // ...
    // const timeDisplay = createRef<Txt>();
    // view.add(<Txt ref={timeDisplay} fill="white" fontSize={40} />);
    //
    // yield* loop(Infinity, () => {
    //   timeDisplay().text(TimeFormatter.format(view.time()));
    //   return waitFor(1 / 30); // Update roughly 30 times per second
    // });
    ```
    - `view.time()`: Returns the current time of the scene in seconds.

**Why Use These?**

- **Frame-Perfect Timing:** If you need animations to align with specific frame counts, especially when working with video footage or integrating with other frame-based media.
- **Displaying Time:** For creating timers, clocks, or displaying playback progress.
- **Clarity:** Expressing short durations in frames (e.g., `framesToSeconds(5)`) can sometimes be more intuitive for animators used to frame-based workflows.

---

This covers `Random`, more advanced `Vector2`/`Color` utilities, and Timing/Frame utilities. These are very helpful for adding proceduralism, precision, and useful feedback to your animations.

---

Okay, let's continue with **Part 10: Leveraging Core Utilities üõ†Ô∏è** in the Chalchitra Cookbook.

We'll now look at decorators, which are important for understanding how Motion Canvas classes (like components and signals) are often structured internally or when creating custom extensions in TypeScript. Then we'll cover logging and debugging utilities.

---

### 10.4 Decorators in Motion Canvas (Conceptual Overview)

**Goal:** Understand the role of common TypeScript decorators like `@signal`, `@initial`, `@vector2Signal`, `@threadable` in Motion Canvas. While you won't use these directly when writing animations with `chalchitra.py` (as `chalchitra.py` generates the code), understanding them helps in comprehending Motion Canvas's architecture, its examples, and how you might structure custom components if you were working in its TypeScript environment.

**Core Concepts Involved:** Decorators (a TypeScript feature for metaprogramming), simplifying class property and method definitions.

**What are Decorators?**

Decorators are a special kind of declaration that can be attached to classes, methods, accessors, properties, or parameters. They are functions that are called at runtime with information about the decorated declaration and can modify or augment its behavior. Motion Canvas uses them extensively to reduce boilerplate and add specific functionalities.

**For `chalchitra.py` Users:**

- You will **not** type `@signal` directly in your Python code for `chalchitra.py`.
- Instead, `chalchitra.py` aims to provide Pythonic ways (e.g., through its class constructors or specific methods) to achieve the same results that these decorators provide in TypeScript. For example, when you set a property on a `chalchitra.py` node object, `chalchitra.py`'s code generator might produce TypeScript code that uses an underlying signal for that property.
- This section is for your understanding of the Motion Canvas ecosystem and its source code.

**Common Decorators in Motion Canvas:**

1.  **Signal Decorators (`@signal`, `@vector2Signal`, `@colorSignal`, etc.)**

    - **Purpose:** To easily define class properties as Motion Canvas signals, making them reactive and animatable.
    - **How they work (conceptually):** When you decorate a property with `@signal()`, it transforms that property into a getter/setter pair backed by a Motion Canvas signal object.
    - **From `@motion-canvas/core/lib/decorators/signal.ts` (and similar for specialized types):**

      - `@signal()`: For general signal properties. Often needs a type and an `initial` value.
      - `@vector2Signal()`: Specifically for `Vector2` properties, creating a `Vector2Signal`.
      - `@colorSignal()`: Specifically for `Color` properties, creating a `ColorSignal`.
      - `@stringSignal()`, `@numberSignal()`, `@booleanSignal()`: For primitive types.
      - `@compound(['propA', 'propB'])`: Used for properties that are composed of other (often signal) properties. For example, a `size` property might be a compound of `width` and `height`. When `size` is set, it intelligently updates the underlying `width` and `height` signals, and vice-versa.

    - **Conceptual TypeScript Example (if you were making a custom component):**

      ```typescript
      // In a custom Motion Canvas component (TypeScript)
      import { Node, NodeProps } from "@motion-canvas/2d";
      import {
        signal,
        initial,
        numberSignal,
        Vector2Signal,
        vector2Signal,
      } from "@motion-canvas/core";

      interface MyCustomProps extends NodeProps {
        myValue?: number;
        myPosition?: Vector2;
      }

      class MyCustomNode extends Node {
        @initial(0) // Sets the default initial value for the signal
        @numberSignal() // Defines this.myValue as a NumberSignal
        public declare readonly myValue: Signal<number, this>;

        @initial(Vector2.zero)
        @vector2Signal() // Defines this.myPosition as a Vector2Signal
        public declare readonly myPosition: Vector2Signal<this>;

        public constructor(props?: MyCustomProps) {
          super(props);
          // Now this.myValue and this.myPosition are reactive signals
        }
      }
      ```

2.  **`@initial(defaultValue)`**

    - **Purpose:** Sets the initial (default) value for a signal property when it's declared using a signal decorator.
    - **Usage:** Placed just before a signal decorator like `@numberSignal()`.
      ```typescript
      // @initial(100)
      // @numberSignal()
      // public declare readonly speed: Signal<number, this>;
      ```

3.  **`@parser(parseFunction)`**

    - **Purpose:** Allows defining a custom function to parse or transform incoming values before they are set on a signal property.
    - **Usage:**
      ```typescript
      // @parser(parseFloat) // Ensures the value is always a float
      // @numberSignal()
      // public declare readonly someNumericInput: Signal<number, this>;
      ```

4.  **Flow Control Decorators (`@threadable`, `@cancelable`, `@blocking`)**

    - **Purpose:** Used on generator methods (`function*`) within scenes or components to control how they are executed by Motion Canvas's animation scheduler.
    - **From `@motion-canvas/core/lib/flow/decorators.ts`:**
      - **`@threadable()`**: Makes a generator method a "thread." When you call `yield* this.myThreadableMethod()`, it integrates properly with the scene's timeline and can be part of `all`, `sequence`, etc. Most animation methods you write in scenes are implicitly threadable.
      - **`@cancelable(true/false)`**: (If available and used this way) Might control if a thread can be canceled.
      - **`@blocking()`**: (If available) Might indicate a thread that blocks other parallel threads in certain contexts.
    - **Usage:**
      ```typescript
      // class MyScene extends makeScene2D {
      //   @threadable() // Make this method behave like a standard animation task
      //   protected* myCustomAnimationSequence() {
      //     yield* this.rect.fill('red', 1);
      //     yield* waitFor(0.5);
      //     yield* this.rect.fill('blue', 1);
      //   }
      //
      //   protected* Animate() {
      //     yield* this.myCustomAnimationSequence(); // Can now yield* to it
      //   }
      // }
      ```

5.  **`@resolved`**
    - **Purpose:** A decorator often used for methods on `Node` subclasses. It ensures that certain calculations (like layout resolution) are completed before the decorated method's body is executed. This is mostly for internal component development to ensure properties like final size and position are accurate.

**Understanding the "Why":**

These decorators help Motion Canvas developers (and those extending it):

- Keep code DRY (Don't Repeat Yourself) by abstracting common patterns for signal creation and property definition.
- Clearly define the reactive nature of properties.
- Integrate custom methods smoothly into the animation lifecycle.

For `chalchitra.py`, the spirit of these decorators would be captured in how you design your Python classes and their property setters/getters, ensuring that the generated TypeScript code uses signals and animatable properties correctly.

---

### 10.5 Logging and Debugging Utilities

**Goal:** Learn how to output informational messages, warnings, errors, and use specific debugging tools provided by Motion Canvas.

**Core Concepts Involved:** `Logger` class, standard `console` methods, editor's debugging features.

**1. Using the `Logger` Class:**

Motion Canvas provides a `Logger` class for more structured logging than plain `console.log`. It allows for different log levels and can prefix messages with a context (e.g., your component's name).

- **Importing:**

  ```typescript
  import { Logger } from "@motion-canvas/core";
  ```

- **Creating a Logger Instance:**
  It's good practice to create a logger instance with a specific context name.

  ```typescript
  // At the top of your scene file or custom component file
  const logger = new Logger("MySceneName");
  // Or for a specific component:
  // const buttonLogger = new Logger('CustomButton');
  ```

- **Logging Methods:**

  - `logger.debug('A detailed debug message:', dataObject)`: For verbose debugging information.
  - `logger.info('An informational message.')`: General information.
  - `logger.warn('Something to be cautious about.')`: Warnings.
  - `logger.error('An error occurred:', errorObject)`: Errors.
  - `logger.fatal('A critical error, system might be unstable.')`: For very severe errors.

  ```typescript
  // Inside makeScene2D(function* (view) { ... })
  // const logger = new Logger('MyAnimationLogic'); // Create logger for this scene

  logger.info("Starting main animation sequence.");
  yield * myCircle().position.x(100, 1);

  if (myCircle().position.x() !== 100) {
    logger.warn(`Circle X position is unexpected: ${myCircle().position.x()}`);
  }

  try {
    // Potentially error-prone operation
    // yield* someRiskyAnimation();
  } catch (e) {
    logger.error("Risky animation failed", e);
  }
  ```

- **Log Levels:** The Motion Canvas player/editor might have settings to control which log levels are visible (e.g., show only info and above, or show all debug messages).

**2. Standard `console` Methods:**

You can always use the standard JavaScript `console` methods within your Motion Canvas code. These will output to your browser's developer console (when running the editor) or your terminal console (if logs are piped there from Node.js for programmatic rendering).

```typescript
console.log("Current circle X:", myCircleRef().position.x());
console.warn("Potential issue here.");
console.error("Something went wrong.");
console.table({ x: myCircleRef().position.x(), y: myCircleRef().position.y() });
```

These are often the quickest for immediate debugging.

**3. Motion Canvas Editor Debugging Features:**

Don't forget the powerful visual debugging tools built into the Motion Canvas editor:

- **Inspector Panel:** Select any node in the preview or scene graph to see and often _live-edit_ its properties (signals). This is incredibly useful for tweaking values.
- **Scene Graph:** View the hierarchy of your nodes.
- **Timeline Scrubber:** Drag the playhead on the timeline to scrub through your animation and see the state at any point.
- **Player Controls:** Play, pause, step frame-by-frame, control playback speed.
- **Log Output:** The editor usually has a panel to display logs from `Logger` and `console`.
- **Debug Flags:** The editor might have debug flags to overlay information like node outlines, origins, or performance metrics. (e.g., `view.player.debug(...)` or similar from code, or UI toggles).

**4. Specific `debug` Utilities (if available from Motion Canvas API):**

Motion Canvas _might_ provide specific utility functions under a `debug` namespace for drawing visual aids directly onto the canvas (e.g., rendering a vector, outlining a path).

- The codebase shows a `debug` namespace in `@motion-canvas/core` with functions like `debugPoint`, `debugVector`, `debugRect`, `debugCircle`, `debugLine`, `debugPath`, `debugPoints`. These are intended to be used within a `Canvas` drawing function or similar custom rendering context to draw visual debug information.

  ```typescript
  // Conceptual usage within a <Canvas /> component's draw function:
  // import {debug} from '@motion-canvas/core';
  // import {Canvas} from '@motion-canvas/2d';
  //
  // const myPointSignal = createSignal(Vector2.zero);
  // view.add(
  //   <Canvas
  //     width={200} height={200}
  //     draw={ctx => {
  //       debug.debugPoint(ctx, myPointSignal(), 5, 'red');
  //       // ... other drawing
  //     }}
  //     dependencies={[myPointSignal]}
  //   />
  // );
  ```

  These debug drawing functions are for visualizing data directly on your animation canvas, which can be very helpful.

**Tips for Debugging:**

- **Isolate the Problem:** If something goes wrong, try to create a minimal reproducible example with just the problematic component or animation.
- **Log Signal Values:** When dealing with signals, log their values at different points in your animation to see if they are changing as expected.
- **Use the Editor's Inspector:** It's often the fastest way to see the current state of your nodes.
- **Check Default Values:** Sometimes unexpected behavior comes from default property values. The documentation or inspecting a node can reveal these.

---

This covers an overview of decorators (important for understanding Motion Canvas's structure) and common logging/debugging techniques.
